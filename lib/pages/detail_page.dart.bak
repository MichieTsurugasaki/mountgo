import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import '../widgets/simple_sun_icon.dart';
import '../services/firestore_service.dart';
import '../services/chat_service.dart';
import '../services/open_meteo_service.dart';
import '../services/places_service.dart';
import '../services/mountain_info_ai_service.dart';
import '../services/api_service.dart';
import '../services/weather_score.dart';
import 'plan_history_page.dart'; // âœ… å±¥æ­´ãƒšãƒ¼ã‚¸

// ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ï¼šç›®çš„åœ°æƒ…å ±
class _Dest {
  final String title;
  final double? lat;
  final double? lng;
  _Dest({required this.title, required this.lat, required this.lng});
}

class DetailPage extends StatefulWidget {
  final Map<String, dynamic> mountain;
  final String departureLabel;
  final DateTime? plannedDate;
  final double? departureLat;
  final double? departureLng;
  final String? selectedLevel;
  final String? selectedAccessTime;
  final String? selectedCourseTime;
  final List<String>? selectedStyles;
  final List<String>? selectedPurposes;
  final Map<String, String>? priorityPrefs;

  const DetailPage({
    super.key,
    required this.mountain,
    required this.departureLabel,
    this.plannedDate,
    this.departureLat,
    this.departureLng,
    this.selectedLevel,
    this.selectedAccessTime,
    this.selectedCourseTime,
    this.selectedStyles,
    this.selectedPurposes,
    this.priorityPrefs,
  });

  @override
  State<DetailPage> createState() => _DetailPageState();
}

class _DetailPageState extends State<DetailPage> {
  final TextEditingController _chatCtrl = TextEditingController();
  bool _isFavorite = false;
  int? _selectedTrailheadIndex;
  // State fields
  String _placesSortMode = 'rating'; // or 'distance'
  int _descReload = 0; // AIèª¬æ˜ã®å†å–å¾—ç”¨
  bool _chatFirestoreOk = true; // Firestoreåˆ©ç”¨å¯å¦
  final List<Map<String, String>> _localChat = []; // Firestoreä¸å¯æ™‚ã®ãƒ­ãƒ¼ã‚«ãƒ«ãƒ­ã‚°
  bool _isSendingLocalAi = false; // é€ä¿¡ä¸­ã‚¹ãƒ”ãƒŠãƒ¼è¡¨ç¤º
  List<Map<String, String>> _userSpots = []; // ãƒ¦ãƒ¼ã‚¶ãƒ¼è¿½åŠ ã®å‘¨è¾ºã‚¹ãƒãƒƒãƒˆ

  Future<void> _loadUserSpots() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final key = 'user_spots:${(widget.mountain['name'] ?? '').toString()}';
      final raw = prefs.getString(key);
      if (raw != null && raw.isNotEmpty) {
        final decoded = json.decode(raw);
        if (decoded is List) {
          final list = decoded
              .whereType<Map>()
              .map((m) => m.map((k, v) => MapEntry(k.toString(), (v ?? '').toString())))
              .toList();
          if (mounted) setState(() => _userSpots = list.cast<Map<String, String>>());
        }
      }
    } catch (_) {}
  }

  Future<void> _saveUserSpots() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final key = 'user_spots:${(widget.mountain['name'] ?? '').toString()}';
      await prefs.setString(key, json.encode(_userSpots));
    } catch (_) {}
  }

  Future<void> _showAddSpotDialog() async {
    final nameCtrl = TextEditingController();
    final urlCtrl = TextEditingController();
    final memoCtrl = TextEditingController();
    await showDialog(
      context: context,
      builder: (ctx) {
        return AlertDialog(
          title: const Text('å‘¨è¾ºã‚¹ãƒãƒƒãƒˆã‚’è¿½åŠ '),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                TextField(
                  controller: nameCtrl,
                  decoration: const InputDecoration(labelText: 'åå‰ï¼ˆå¿…é ˆï¼‰'),
                  textInputAction: TextInputAction.next,
                ),
                const SizedBox(height: 8),
                TextField(
                  controller: urlCtrl,
                  decoration: const InputDecoration(labelText: 'URLï¼ˆä»»æ„ï¼‰'),
                  keyboardType: TextInputType.url,
                ),
                const SizedBox(height: 8),
                TextField(
                  controller: memoCtrl,
                  decoration: const InputDecoration(labelText: 'ãƒ¡ãƒ¢ï¼ˆä»»æ„ï¼‰'),
                  maxLines: 3,
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(ctx),
              child: const Text('ã‚­ãƒ£ãƒ³ã‚»ãƒ«'),
            ),
            TextButton(
              onPressed: () async {
                final name = nameCtrl.text.trim();
                final url = urlCtrl.text.trim();
                final memo = memoCtrl.text.trim();
                if (name.isEmpty) return; // å¿…é ˆ
                setState(() {
                  _userSpots.add({'name': name, 'url': url, 'memo': memo});
                });
                await _saveUserSpots();
                if (mounted) Navigator.pop(ctx);
              },
              child: const Text('è¿½åŠ ã™ã‚‹'),
            ),
          ],
        );
      },
    );
  }

  @override
  void initState() {
    super.initState();
    _loadUserSpots();
  }

  @override
  Widget build(BuildContext context) {
    final mountain = widget.mountain;

    return Scaffold(
      backgroundColor: const Color(0xFFF8FBFB),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [
              Color(0xFF1E4F45), // deep green
              Color(0xFF2B6F63), // pine
              Color(0xFFF7D154), // warm yellow
            ],
            stops: [0.0, 0.55, 1.0],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
        ),
        child: SafeArea(
          child: SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(16, 10, 16, 100),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: 20),
                _appTitle(),
                const SizedBox(height: 10),
                _header(context, mountain),
                const SizedBox(height: 10),
                _mountainInfoCard(mountain),
                if (widget.plannedDate != null) ...[
                  const SizedBox(height: 10),
                  _scheduleBanner(widget.plannedDate!),
                ],
                const SizedBox(height: 16),
                _weatherIndexCard(mountain),
                const SizedBox(height: 12),
                _weatherCard(mountain),
                const SizedBox(height: 16),
                _mapCard(mountain), // âœ… åœ°å›³ã‚«ãƒ¼ãƒ‰
                const SizedBox(height: 16),
                _trailheadInfoCard(mountain),
                const SizedBox(height: 16),
                _descriptionCard(mountain),
                const SizedBox(height: 16),
                _relaxLinksCard(mountain),
                const SizedBox(height: 16),
                _gourmetLinksCard(mountain),
                const SizedBox(height: 16),
                _nearbyPlacesCard(mountain),
                const SizedBox(height: 20),
                _aiRecommendationCard(), // âœ… AIãŠã™ã™ã‚ã‚«ãƒ¼ãƒ‰
                const SizedBox(height: 20),
                _chatSection(),
                const SizedBox(height: 24),
                _shareButtons(),
                const SizedBox(height: 20),
                _saveAndHistoryButtons(context),
              ],
            ),
          ),
        ),
      ),
      bottomNavigationBar: _fixedBackButton(context),
    );
  }

  // å›ºå®šãƒ•ãƒƒã‚¿ãƒ¼ï¼šæ¤œç´¢çµæœã«æˆ»ã‚‹
  Widget _fixedBackButton(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          colors: [Color(0xFF2E7D32), Color(0xFF7CB342), Color(0xFF104E41)],
          begin: Alignment.centerLeft,
          end: Alignment.centerRight,
        ),
        boxShadow: [
          BoxShadow(
            color: const Color(0xFF104E41).withValues(alpha: 0.3),
            blurRadius: 12,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: SafeArea(
        child: InkWell(
          onTap: () => Navigator.pop(context),
          child: Container(
            padding: const EdgeInsets.symmetric(vertical: 16),
            child: const Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.arrow_back_ios, color: Colors.white, size: 18),
                SizedBox(width: 8),
                Text(
                  'æ¤œç´¢çµæœã«æˆ»ã‚‹',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 0.5,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  // ğŸ’š ãƒ˜ãƒƒãƒ€ãƒ¼
  Widget _header(BuildContext context, Map<String, dynamic> mountain) {
    return Row(
      children: [
        IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => Navigator.pop(context),
        ),
        Expanded(
          child: Center(
            child: Text(
              "${mountain["name"]}ï¼ˆ${mountain["pref"]}ï¼‰",
              style: const TextStyle(
                fontSize: 22,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
          ),
        ),
        IconButton(
          icon: Icon(
            _isFavorite ? Icons.favorite : Icons.favorite_border,
            color: Colors.pinkAccent,
          ),
          onPressed: () => setState(() => _isFavorite = !_isFavorite),
        ),
      ],
    );
  }

  // ï¿½ ã‚¢ãƒ—ãƒªã‚¿ã‚¤ãƒˆãƒ«ï¼ˆæ¤œç´¢ã¨çµ±ä¸€ï¼‰
  Widget _appTitle() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      mainAxisSize: MainAxisSize.min,
      children: const [
        SimpleSunIcon(size: 20),
        SizedBox(width: 8),
        Text(
          'æ™´ã‚Œå±± SEARCH',
          style: TextStyle(
            color: Colors.white,
            fontSize: 24,
            fontWeight: FontWeight.w800,
            letterSpacing: 1.2,
          ),
        ),
      ],
    );
  }

  // ğŸ—“ æ—¥ç¨‹ï¼ˆè©³ç´°ãƒšãƒ¼ã‚¸ä¸Šéƒ¨ï¼‰
  Widget _scheduleBanner(DateTime day) {
    final d = DateTime(day.year, day.month, day.day)
        .toIso8601String()
        .split('T')
        .first
        .replaceAll('-', '/');
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: 0.92),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: const Color(0xFF00939C).withValues(alpha: 0.25)),
      ),
      child: Row(
        children: [
          const Icon(Icons.calendar_month_rounded, color: Color(0xFF00939C)),
          const SizedBox(width: 8),
          Text('ç™»å±±æ—¥ï¼š$d', style: const TextStyle(fontWeight: FontWeight.w700)),
        ],
      ),
    );
  }

  // ï¿½ğŸŒ¤ å¤©æ°—ã‚«ãƒ¼ãƒ‰ï¼ˆAPIé€£æºï¼šç™»å±±æ—¥ã®24æ™‚é–“ãƒ»æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰
  Widget _weatherCard(Map<String, dynamic> m) {
    final double? lat = (m['lat'] is num) ? (m['lat'] as num).toDouble() : null;
    final double? lng = (m['lng'] is num) ? (m['lng'] as num).toDouble() : null;
    final DateTime target = widget.plannedDate ?? DateTime.now();

    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            "â›° å±±ã®å¤©æ°—ï¼ˆ1æ™‚é–“ã”ã¨ï¼‰",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          if (lat == null || lng == null)
            const Text(
              'ä½ç½®æƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã‚‹ãŸã‚ã€ã“ã®å±±ã®æ™‚é–“åˆ¥å¤©æ°—ã‚’è¡¨ç¤ºã§ãã¾ã›ã‚“ã€‚',
              style: TextStyle(color: Colors.black54),
            )
          else
            FutureBuilder<List<Map<String, dynamic>>>(
              future: OpenMeteoService.fetchHourly(lat, lng, day: target),
              builder: (context, snap) {
                if (snap.connectionState == ConnectionState.waiting) {
                  return const Padding(
                    padding: EdgeInsets.symmetric(vertical: 8),
                    child: LinearProgressIndicator(minHeight: 4),
                  );
                }
                if (snap.hasError) {
                  return const Text('å¤©æ°—ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚', 
                    style: TextStyle(color: Colors.black87));
                }
                final data = snap.data ?? const [];
                if (data.isEmpty) {
                  return const Text('ã“ã®æ—¥ã®æ™‚é–“åˆ¥å¤©æ°—ãƒ‡ãƒ¼ã‚¿ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚',
                    style: TextStyle(color: Colors.black87));
                }
                return SizedBox(
                  height: 150,
                  child: ListView.separated(
                    scrollDirection: Axis.horizontal,
                    itemCount: data.length,
                    separatorBuilder: (_, __) => const SizedBox(width: 10),
                    itemBuilder: (context, i) {
                      final e = data[i];
                      final timeStr = e['time']?.toString() ?? '';
                      final hh = (timeStr.length >= 13)
                          ? timeStr.substring(11, 13)
                          : '';
                      final hourLabel = hh.isNotEmpty ? '${int.tryParse(hh) ?? 0}æ™‚' : '';
                      final wcode = (e['weathercode'] as int?) ?? 0;
                      final emoji = OpenMeteoService.emojiFromWeatherCode(wcode);
                      final temp = (e['temp_c'] as num?)?.toDouble();
                      final wind = (e['wind_m_s'] as num?)?.toDouble();
                      final pop = ((e['pop'] as num?)?.toDouble() ?? 0.0) * 100;

                      return Container(
                        width: 100,
                        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
                        decoration: BoxDecoration(
                          gradient: const LinearGradient(
                            colors: [Color(0xFFFFF8E1), Color(0xFFFFFFFF)],
                            begin: Alignment.topCenter,
                            end: Alignment.bottomCenter,
                          ),
                          borderRadius: BorderRadius.circular(16),
                          border: Border.all(color: const Color(0xFF00939C).withValues(alpha: 0.3)),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withValues(alpha: 0.06),
                              blurRadius: 6,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(hourLabel, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 13)),
                            const SizedBox(height: 4),
                            _weatherVisual(wcode, emoji),
                            const SizedBox(height: 6),
                            if (temp != null)
                              Text('${temp.round()}Â°C', style: const TextStyle(fontSize: 15, fontWeight: FontWeight.w700, color: Color(0xFF1E4F45))),
                            const SizedBox(height: 6),
                            // é¢¨é€Ÿ
                            if (wind != null) ...[
                              Row(
                                mainAxisAlignment: MainAxisAlignment.center,
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  const Icon(Icons.air, size: 14, color: Color(0xFF00939C)),
                                  const SizedBox(width: 2),
                                  Flexible(
                                    child: Text('é¢¨ ${wind.toStringAsFixed(1)}m/s', 
                                      style: const TextStyle(fontSize: 10, color: Color(0xFF424242)),
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 3),
                            ],
                            // é™æ°´ç¢ºç‡
                            Row(
                              mainAxisAlignment: MainAxisAlignment.center,
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                const Icon(Icons.water_drop, size: 14, color: Color(0xFF10ABB4)),
                                const SizedBox(width: 2),
                                Flexible(
                                  child: Text('é›¨ ${pop.round()}%', 
                                    style: const TextStyle(fontSize: 10, color: Color(0xFF424242)),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                );
              },
            ),
        ],
      ),
    );
  }

  Widget _weatherVisual(int weatherCode, String emoji) {
    // Clear sky (0) or mostly clear (1) â†’ simple orange sun icon
    if (weatherCode == 0 || weatherCode == 1) {
      return const SimpleSunIcon(size: 26);
    }
    // Partly cloudy
    if (weatherCode == 2) {
      return const Icon(Icons.wb_cloudy, color: Color(0xFF90A4AE), size: 30);
    }
    // Cloud / rain fallback: keep emoji for variety
    return Text(emoji, style: const TextStyle(fontSize: 32));
  }

  // ğŸ” å±±æƒ…å ±
  Widget _descriptionCard(Map<String, dynamic> m) {
    final hasDbDesc = ((m['description'] ?? '').toString().trim().isNotEmpty);
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("ğŸ” å±±ã®æƒ…å ±",
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 20)),
          const SizedBox(height: 10),
          if (hasDbDesc)
            Text(
              (m['description'] as String).trim(),
              style: const TextStyle(height: 1.6, color: Colors.black87),
            )
          else
            FutureBuilder<String?>(
              key: ValueKey('ai-desc-${m['name']}-${_descReload}'),
              future: MountainInfoAIService.getOrGenerateDescription(m),
              builder: (context, snap) {
                if (snap.connectionState == ConnectionState.waiting) {
                  return const Padding(
                    padding: EdgeInsets.symmetric(vertical: 4),
                    child: LinearProgressIndicator(minHeight: 4),
                  );
                }
                final text = (snap.data ?? '').toString().trim();
                if (text.isEmpty) {
                  return Row(
                    children: [
                      const Expanded(
                        child: Text(
                          'èª¬æ˜ãªã—ï¼ˆAIç”Ÿæˆã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸï¼‰',
                          style: TextStyle(color: Colors.black54),
                        ),
                      ),
                      TextButton.icon(
                        onPressed: () => setState(() => _descReload++),
                        icon: const Icon(Icons.refresh, size: 18),
                        label: const Text('å†è©¦è¡Œ'),
                      ),
                    ],
                  );
                }
                return Text(
                  text,
                  style: const TextStyle(height: 1.6, color: Colors.black87),
                );
              },
            ),
          const SizedBox(height: 12),
          SizedBox(
            width: double.infinity,
            child: OutlinedButton(
              onPressed: () => launchUrl(
                  Uri.parse("https://yamap.com/mountains/108"),
                  mode: LaunchMode.externalApplication),
              style: OutlinedButton.styleFrom(
                side: const BorderSide(color: Color(0xFFE57373), width: 1.5),
                foregroundColor: const Color(0xFFE57373),
                backgroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 14),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(40)),
              ),
              child: const Text(
                "ğŸ§­ YAMAPã§ã‚³ãƒ¼ã‚¹ã‚’ã¿ã‚‹",
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
            ),
          ),
        ],
      ),
    );
  }

  // ğŸ“ˆ å¤©æ°—æŒ‡æ•° & ä»Šæ—¥ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹ï¼ˆ1æ—¥å˜ä½ï¼‰
  Widget _weatherIndexCard(Map<String, dynamic> m) {
    final double? lat = (m['lat'] is num) ? (m['lat'] as num).toDouble() : null;
    final double? lng = (m['lng'] is num) ? (m['lng'] as num).toDouble() : null;
    final DateTime target = widget.plannedDate ?? DateTime.now();

    if (lat == null || lng == null) {
      return _cardContainer(
        child: const Text('ä½ç½®æƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã‚‹ãŸã‚ã€ã“ã®æ—¥ã®å¤©æ°—æŒ‡æ•°ã‚’è¡¨ç¤ºã§ãã¾ã›ã‚“ã€‚', style: TextStyle(color: Colors.black54)),
      );
    }

    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('ğŸ“ˆ å¤©æ°—æŒ‡æ•°ã¨ä»Šæ—¥ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
          const SizedBox(height: 6),
          FutureBuilder<List<Map<String, dynamic>>>(
            future: OpenMeteoService.fetchDaily(lat, lng, days: 14),
            builder: (context, snap) {
              if (snap.connectionState == ConnectionState.waiting) {
                return const LinearProgressIndicator(minHeight: 4);
              }
              final days = snap.data ?? const [];
              if (days.isEmpty) {
                return const Text('å¤©æ°—æŒ‡æ•°ã‚’è¨ˆç®—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
                  style: TextStyle(color: Colors.black87));
              }
              final picked = OpenMeteoService.chooseBestOrDate(days, target: target) ?? days.first;
              final f = {
                'pop': (picked['pop'] as num?)?.toDouble() ?? double.nan,
                'wind_m_s': (picked['wind_m_s'] as num?)?.toDouble() ?? double.nan,
                'cloud_pct': (picked['cloud_pct'] as num?)?.toDouble() ?? double.nan,
                'temp_c': (picked['temp_c'] as num?)?.toDouble() ?? double.nan,
                'precip_mm': 0.0,
              };
              final res = WeatherScore.scoreDay(f);
              final score = (res['score'] as int?) ?? 0;
              final reason = (res['reason'] as String?) ?? '';
              final breakdown = (res['breakdown'] as Map?) ?? const {};
              final advice = _buildDailyAdvice(score, breakdown, picked);

              Color badgeColor;
              if (score >= 75) {
                badgeColor = const Color(0xFF2E7D32);
              } else if (score >= 50) {
                badgeColor = const Color(0xFFF9A825);
              } else {
                badgeColor = const Color(0xFFD32F2F);
              }

              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                        decoration: BoxDecoration(color: badgeColor, borderRadius: BorderRadius.circular(20)),
                        child: Text('$score', style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                      ),
                      const SizedBox(width: 8),
                      const Text('å¤©æ°—æŒ‡æ•°ï¼ˆ0-100ï¼‰', style: TextStyle(fontWeight: FontWeight.w600)),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(reason, style: const TextStyle(color: Colors.black87)),
                  const SizedBox(height: 6),
                  Text(advice, style: const TextStyle(color: Colors.black87, height: 1.5)),
                ],
              );
            },
          ),
        ],
      ),
    );
  }

  String _buildDailyAdvice(int score, Map breakdown, Map picked) {
    if (score >= 85) {
      return 'ä»Šæ—¥ã¯çµ¶å¥½ã®å±±æ—¥å’Œï¼å±•æœ›ã‚„ç¨œç·šæ­©ãã‚’ãŸã£ã·ã‚Šæ¥½ã—ã‚ãã†ã§ã™ã€‚æ—¥ç„¼ã‘ãƒ»æ°´åˆ†è£œçµ¦ã®æº–å‚™ã‚’ãŠå¿˜ã‚Œãªãã€‚';
    } else if (score >= 70) {
      return 'è‰¯ã„æ¡ä»¶ã§ã™ã€‚åˆå‰ã‚’ä¸­å¿ƒã«è¨ˆç”»ã™ã‚‹ã¨ã€ã‚ˆã‚Šæ°—æŒã¡ã‚ˆãæ­©ã‘ã¾ã™ã€‚åˆå¾Œã¯ä½™è£•ã‚’ã‚‚ã£ã¦å®‰å…¨ã«ã€‚';
    } else if (score >= 55) {
      return 'å°‘ã—æºã‚‰ãã¯ã‚ã‚Šã¾ã™ãŒã€æ¨¹æ—å¸¯ä¸­å¿ƒã‚„ä½å±±ã‚³ãƒ¼ã‚¹ãªã‚‰å¿«é©ã«æ¥½ã—ã‚ã¾ã™ã€‚æ—©ã‚ã®è¡Œå‹•ã§ã‚†ã¨ã‚Šã‚’ã€‚';
    } else {
      return 'ä»Šæ—¥ã¯é™ã‹ãªå±±æ™‚é–“ã‚’ã€‚è¿‘å ´ã®ãƒã‚¤ã‚­ãƒ³ã‚°ã‚„åˆ¥æ—¥ã®å¿«æ™´ç‹™ã„ã‚‚ç´ æ•µã§ã™ã€‚å®‰å…¨ç¬¬ä¸€ã§ç„¡ç†ãªãã€‚';
    }
  }

  // ğŸš ç™»å±±å£æƒ…å ±ã‚«ãƒ¼ãƒ‰
  Widget _trailheadInfoCard(Map<String, dynamic> m) {
    String orDash(String s) => (s.isNotEmpty) ? s : 'â€”';
    final List ths = (m['trailheads'] is List) ? (m['trailheads'] as List) : const [];

    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'ğŸš ç™»å±±å£æƒ…å ±',
            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18),
          ),
          const SizedBox(height: 10),
          if (ths.isEmpty) ...[
            _trailRow(Icons.flag, 'ç™»å±±å£å', orDash('${m['name'] ?? ''} ç™»å±±å£')),
            const SizedBox(height: 6),
            _trailRow(Icons.place, 'ä½æ‰€', orDash((m['address'] ?? '').toString())),
            const SizedBox(height: 6),
            _trailRow(Icons.local_parking, 'é§è»Šå ´', orDash((m['parking'] ?? '').toString())),
            const SizedBox(height: 6),
            _trailRow(Icons.wc, 'ãƒˆã‚¤ãƒ¬', orDash((m['toilet'] ?? '').toString())),
          ] else ...[
            ...ths.asMap().entries.map((entry) {
              final i = entry.key;
              final th = Map<String, dynamic>.from(entry.value as Map);
              final tname = (th['name'] ?? '${m['name'] ?? ''} ç™»å±±å£${i + 1}').toString();
              final taddr = (th['address'] ?? '').toString();
              final tpark = (th['parking'] ?? '').toString();
              final ttlt = (th['toiletSeason'] ?? th['toilet'] ?? '').toString();
              return Padding(
                padding: EdgeInsets.only(bottom: i == ths.length - 1 ? 0 : 10),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _trailRow(Icons.flag, 'ç™»å±±å£å', orDash(tname)),
                    const SizedBox(height: 6),
                    _trailRow(Icons.place, 'ä½æ‰€', orDash(taddr)),
                    const SizedBox(height: 6),
                    _trailRow(Icons.local_parking, 'é§è»Šå ´', orDash(tpark)),
                    const SizedBox(height: 6),
                    _trailRow(Icons.wc, 'ãƒˆã‚¤ãƒ¬', orDash(ttlt)),
                  ],
                ),
              );
            })
          ]
        ],
      ),
    );
  }

  Widget _trailRow(IconData icon, String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, color: const Color(0xFF267365)),
        const SizedBox(width: 10),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label, style: const TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 2),
              Text(value),
            ],
          ),
        )
      ],
    );
  }

  // ğŸ§­ å‘¨è¾ºã‚¹ãƒãƒƒãƒˆï¼ˆGoogle Places ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã¨ãã®ã¿è¡¨ç¤ºï¼‰
  Widget _nearbyPlacesCard(Map<String, dynamic> m) {
    if (!PlacesService.isConfigured) {
      return const SizedBox.shrink();
    }
    final List ths = (m['trailheads'] is List) ? (m['trailheads'] as List) : const [];
    double? lat = (m['lat'] is num) ? (m['lat'] as num).toDouble() : null;
    double? lng = (m['lng'] is num) ? (m['lng'] as num).toDouble() : null;
    if (ths.isNotEmpty) {
      final int idx = _selectedTrailheadIndex ?? 0;
      final Map th = Map.from(ths[idx]);
      final tlat = th['lat'];
      final tlng = th['lng'];
      if (tlat is num && tlng is num) {
        lat = tlat.toDouble();
        lng = tlng.toDouble();
      }
    }
    if (lat == null || lng == null) {
      return const SizedBox.shrink();
    }
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('ğŸ” å‘¨è¾ºã‚¹ãƒãƒƒãƒˆï¼ˆGoogleï¼‰', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
          const SizedBox(height: 8),
          Row(
            children: [
              ChoiceChip(
                label: const Text('è©•ä¾¡é †'),
                selected: _placesSortMode == 'rating',
                onSelected: (v) => setState(() => _placesSortMode = 'rating'),
              ),
              const SizedBox(width: 8),
              ChoiceChip(
                label: const Text('è·é›¢é †'),
                selected: _placesSortMode == 'distance',
                onSelected: (v) => setState(() => _placesSortMode = 'distance'),
              ),
            ],
          ),
          const SizedBox(height: 8),
          FutureBuilder<List<Map<String, dynamic>>>(
            future: PlacesService.nearbyOnsenAndFoodWeighted(lat, lng, radiusMeters: 15000, sort: _placesSortMode),
            builder: (context, snap) {
              if (snap.connectionState == ConnectionState.waiting) {
                return const LinearProgressIndicator(minHeight: 4);
              }
              if (!snap.hasData || snap.data == null) {
                return _emptySpotsBlock(showAdd: true);
              }
              final show = snap.data!;
              if (show.isEmpty) {
                return _emptySpotsBlock(showAdd: true);
              }
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  ...show.map((e) {
                    final rating = (e['rating'] as num?)?.toDouble();
                    final distKm = (e['distanceKm'] as num?)?.toDouble();
                    final subtitle = [
                      if (rating != null && rating > 0) 'â­ ${rating.toStringAsFixed(1)}',
                      if (distKm != null) '${distKm.toStringAsFixed(1)}km',
                      if ((e['desc'] ?? '').toString().isNotEmpty) (e['desc'] as String),
                    ].join(' ãƒ» ');
                    return GestureDetector(
                      onTap: () => launchUrl(Uri.parse(e['url']), mode: LaunchMode.externalApplication),
                      child: Container(
                        margin: const EdgeInsets.only(bottom: 8),
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.white,
                          border: Border.all(color: const Color(0xFF267365).withValues(alpha: 0.3)),
                          borderRadius: BorderRadius.circular(14),
                        ),
                        child: ListTile(
                          title: Text(e['name'], style: const TextStyle(fontWeight: FontWeight.bold)),
                          subtitle: Text(subtitle),
                          trailing: const Icon(Icons.map, color: Color(0xFF267365)),
                        ),
                      ),
                    );
                  }).toList(),
                  if (_userSpots.isNotEmpty) ...[
                    const SizedBox(height: 10),
                    const Text('ğŸ“ ãƒ¦ãƒ¼ã‚¶ãƒ¼è¿½åŠ ã‚¹ãƒãƒƒãƒˆ', style: TextStyle(fontWeight: FontWeight.bold)),
                    const SizedBox(height: 6),
                    ..._userSpots.map((e) {
                      final subtitle = [
                        if ((e['memo'] ?? '').toString().isNotEmpty) (e['memo'] ?? ''),
                        if ((e['url'] ?? '').toString().isNotEmpty) 'ãƒªãƒ³ã‚¯ã‚ã‚Š',
                      ].where((s) => s.isNotEmpty).join(' ãƒ» ');
                      return GestureDetector(
                        onTap: () {
                          final u = (e['url'] ?? '').trim();
                          if (u.isNotEmpty) launchUrl(Uri.parse(u), mode: LaunchMode.externalApplication);
                        },
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF9FBFA),
                            border: Border.all(color: const Color(0xFF267365).withValues(alpha: 0.2)),
                            borderRadius: BorderRadius.circular(14),
                          ),
                          child: ListTile(
                            title: Text(e['name'] ?? '', style: const TextStyle(fontWeight: FontWeight.bold)),
                            subtitle: Text(subtitle.isEmpty ? 'â€”' : subtitle),
                            trailing: const Icon(Icons.open_in_new, color: Color(0xFF267365)),
                          ),
                        ),
                      );
                    }).toList(),
                  ],
                ],
              );
            },
          ),
          if (_userSpots.isEmpty) ...[
            const SizedBox(height: 8),
            _emptySpotsHintNote(),
          ]
        ],
      ),
    );
  }

  Widget _emptySpotsBlock({bool showAdd = false}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: const Color(0xFFF0F7F7),
            border: Border.all(color: const Color(0xFF267365).withValues(alpha: 0.25)),
            borderRadius: BorderRadius.circular(12),
          ),
          child: const Text(
            'å‘¨è¾ºã‚¹ãƒãƒƒãƒˆã®æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“ã€‚è¦‹ã¤ã‘ãŸæƒ…å ±ã‚’è¿½åŠ ã—ã¦ã€æ¬¡ã«è¨ªã‚Œã‚‹æ–¹ã«å½¹ç«‹ã¦ã¾ã—ã‚‡ã†ã€‚',
            style: TextStyle(color: Colors.black87),
          ),
        ),
        const SizedBox(height: 8),
        if (showAdd)
          Align(
            alignment: Alignment.centerLeft,
            child: ElevatedButton.icon(
              onPressed: _showAddSpotDialog,
              icon: const Icon(Icons.add, color: Colors.white),
              label: const Text('ã‚¹ãƒãƒƒãƒˆã‚’è¿½åŠ ', style: TextStyle(color: Colors.white)),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF267365),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
              ),
            ),
          ),
        if (_userSpots.isNotEmpty) ...[
          const SizedBox(height: 8),
          const Text('ğŸ“ ãƒ¦ãƒ¼ã‚¶ãƒ¼è¿½åŠ ã‚¹ãƒãƒƒãƒˆ', style: TextStyle(fontWeight: FontWeight.bold)),
          const SizedBox(height: 6),
          ..._userSpots.map((e) {
            final subtitle = [
              if ((e['memo'] ?? '').toString().isNotEmpty) (e['memo'] ?? ''),
              if ((e['url'] ?? '').toString().isNotEmpty) 'ãƒªãƒ³ã‚¯ã‚ã‚Š',
            ].where((s) => s.isNotEmpty).join(' ãƒ» ');
            return GestureDetector(
              onTap: () {
                final u = (e['url'] ?? '').trim();
                if (u.isNotEmpty) launchUrl(Uri.parse(u), mode: LaunchMode.externalApplication);
              },
              child: Container(
                margin: const EdgeInsets.only(bottom: 8),
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: const Color(0xFFF9FBFA),
                  border: Border.all(color: const Color(0xFF267365).withValues(alpha: 0.2)),
                  borderRadius: BorderRadius.circular(14),
                ),
                child: ListTile(
                  title: Text(e['name'] ?? '', style: const TextStyle(fontWeight: FontWeight.bold)),
                  subtitle: Text(subtitle.isEmpty ? 'â€”' : subtitle),
                  trailing: const Icon(Icons.open_in_new, color: Color(0xFF267365)),
                ),
              ),
            );
          }).toList(),
        ],
      ],
    );
  }

  Widget _emptySpotsHintNote() {
    return const Text(
      'æ‰‹å…ƒã®æƒ…å ±ï¼ˆæ¸©æ³‰ãƒ»é£Ÿäº‹ãƒ»è¦³å…‰ã‚¹ãƒãƒƒãƒˆãªã©ï¼‰ãŒã‚ã‚Œã°ã€Œã‚¹ãƒãƒƒãƒˆã‚’è¿½åŠ ã€ã‹ã‚‰è¿½è¨˜ã§ãã¾ã™ã€‚',
      style: TextStyle(color: Colors.black54, fontSize: 13.5),
    );
  }

  // ğŸ—º åœ°å›³ã‚«ãƒ¼ãƒ‰ï¼ˆâœ…è¿½åŠ ï¼‰
  Widget _mapCard(Map<String, dynamic> mountain) {
    final double? lat = (mountain['lat'] is num) ? (mountain['lat'] as num).toDouble() : null;
    final double? lng = (mountain['lng'] is num) ? (mountain['lng'] as num).toDouble() : null;
    // trailheads
    final List ths = (mountain['trailheads'] is List) ? (mountain['trailheads'] as List) : const [];
    double? dLat = lat, dLng = lng;
    if (ths.isNotEmpty) {
      final int idx = _selectedTrailheadIndex ?? 0;
      final Map th = Map.from(ths[idx]);
      final tlat = th['lat'];
      final tlng = th['lng'];
      if (tlat is num && tlng is num) {
        dLat = tlat.toDouble();
        dLng = tlng.toDouble();
      }
    }
    final LatLng pos = (dLat != null && dLng != null) ? LatLng(dLat, dLng) : const LatLng(35.625, 139.243);
    final String mname = (mountain['name'] ?? 'å±±').toString();
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("ğŸ—º ç™»å±±å£ã‚¢ã‚¯ã‚»ã‚¹ãƒãƒƒãƒ—",
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
          if (ths.length > 1) ...[
            const SizedBox(height: 8),
            DropdownButtonFormField<int>(
              value: _selectedTrailheadIndex,
              items: ths.asMap().entries.map((e) {
                final i = e.key;
                final Map th = Map.from(e.value);
                final title = (th['name'] ?? 'ç™»å±±å£${i + 1}').toString();
                return DropdownMenuItem<int>(value: i, child: Text(title));
              }).toList(),
              onChanged: (v) => setState(() => _selectedTrailheadIndex = v),
              decoration: const InputDecoration(
                labelText: 'ç›®çš„åœ°ã®ç™»å±±å£ã‚’é¸æŠ',
                border: OutlineInputBorder(),
                isDense: true,
              ),
            ),
          ],
          const SizedBox(height: 8),
          SizedBox(
            height: 220,
            child: GoogleMap(
              key: ValueKey('map-${_selectedTrailheadIndex ?? -1}'),
              onMapCreated: (controller) {},
              initialCameraPosition: CameraPosition(target: pos, zoom: 11),
              markers: {
                Marker(markerId: const MarkerId("mountain"), position: pos, infoWindow: InfoWindow(title: mname)),
              },
            ),
          ),
          const SizedBox(height: 12),
          ElevatedButton.icon(
            onPressed: () async {
              final oLat = widget.departureLat;
              final oLng = widget.departureLng;
              final String origin = (oLat != null && oLng != null && (oLat != 0 || oLng != 0))
                  ? '${oLat.toStringAsFixed(6)},${oLng.toStringAsFixed(6)}'
                  : (widget.departureLabel.isNotEmpty ? widget.departureLabel : 'å‡ºç™ºåœ°');
              final hasPos = (pos.latitude != 0 && pos.longitude != 0);
              final destination = hasPos ? '${pos.latitude},${pos.longitude}' : '${widget.mountain["name"]} ç™»å±±å£';
              final uri = Uri.https('www.google.com', '/maps/dir/', {
                'api': '1',
                'origin': origin,
                'destination': destination,
                'travelmode': 'driving',
              });
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri, mode: LaunchMode.externalApplication);
              }
            },
            icon: const Icon(Icons.directions_car, color: Colors.white),
            label: const Text("Googleãƒãƒƒãƒ—ã§è»Šãƒ«ãƒ¼ãƒˆ"),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF00939C),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(30)),
            ),
          ),
          const SizedBox(height: 8),
          ElevatedButton.icon(
            onPressed: () async {
              final oLat = widget.departureLat;
              final oLng = widget.departureLng;
              final String origin = (oLat != null && oLng != null && (oLat != 0 || oLng != 0))
                  ? '${oLat.toStringAsFixed(6)},${oLng.toStringAsFixed(6)}'
                  : (widget.departureLabel.isNotEmpty ? widget.departureLabel : 'å‡ºç™ºåœ°');
              final hasPos = (pos.latitude != 0 && pos.longitude != 0);
              final destination = hasPos ? '${pos.latitude},${pos.longitude}' : '${widget.mountain["name"]} ç™»å±±å£';
              final uri = Uri.https('www.google.com', '/maps/dir/', {
                'api': '1',
                'origin': origin,
                'destination': destination,
                'travelmode': 'transit',
              });
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri, mode: LaunchMode.externalApplication);
              }
            },
            icon: const Icon(Icons.train, color: Colors.white),
            label: const Text("Googleãƒãƒƒãƒ—ã§å…¬å…±äº¤é€šãƒ«ãƒ¼ãƒˆ"),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF10ABB4),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(30)),
            ),
          ),
        ],
      ),
    );
  }

  // ğŸ´ å‘¨è¾ºã‚°ãƒ«ãƒ¡ï¼ˆéƒ·åœŸæ–™ç†ãƒ»ãã°ï¼‰
  Widget _gourmetLinksCard(Map<String, dynamic> m) {
    final _Dest d = _resolveDestination(m);
    final base = d.title;
    final lat = d.lat;
    final lng = d.lng;
    final kws = ['éƒ·åœŸæ–™ç†', 'ãã°'];
    return _linksCard(title: 'å‘¨è¾ºã‚°ãƒ«ãƒ¡ ğŸ´', color: const Color(0xFFE91E63), base: base, lat: lat, lng: lng, keywords: kws);
  }

  // â™¨ï¸ å‘¨è¾ºãã¤ã‚ãï¼ˆæ¸©æ³‰ãƒ»ã‚µã‚¦ãƒŠãƒ»æ°‘å®¿ãƒ»æ—…é¤¨ãƒ»ãƒ›ãƒ†ãƒ«ï¼‰
  Widget _relaxLinksCard(Map<String, dynamic> m) {
    final _Dest d = _resolveDestination(m);
    final base = d.title;
    final lat = d.lat;
    final lng = d.lng;
    final kws = ['æ¸©æ³‰', 'ã‚µã‚¦ãƒŠ', 'æ°‘å®¿', 'æ—…é¤¨', 'ãƒ›ãƒ†ãƒ«'];
    return _linksCard(title: 'å‘¨è¾ºãã¤ã‚ã â™¨ï¸', color: const Color(0xFFFF8F00), base: base, lat: lat, lng: lng, keywords: kws);
  }

  _Dest _resolveDestination(Map<String, dynamic> m) {
    final List ths = (m['trailheads'] is List) ? (m['trailheads'] as List) : const [];
    String title = (m['name'] ?? '').toString();
    double? lat = (m['lat'] is num) ? (m['lat'] as num).toDouble() : null;
    double? lng = (m['lng'] is num) ? (m['lng'] as num).toDouble() : null;
    if (ths.isNotEmpty) {
      final int idx = _selectedTrailheadIndex ?? 0;
      final Map th = Map.from(ths[idx]);
      final tlat = th['lat'];
      final tlng = th['lng'];
      if (tlat is num && tlng is num) {
        lat = tlat.toDouble();
        lng = tlng.toDouble();
      }
      title = (th['name'] ?? title).toString();
    }
    return _Dest(title: title, lat: lat, lng: lng);
  }

  Widget _linksCard({
    required String title,
    required Color color,
    required String base,
    required double? lat,
    required double? lng,
    required List<String> keywords,
  }) {
    final center = (lat != null && lng != null) ? '@${lat.toStringAsFixed(5)},${lng.toStringAsFixed(5)},14z' : '';
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(title, style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: color)),
          const SizedBox(height: 10),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: keywords.map((kw) {
              final q = '$base $kw';
              final url = Uri.parse('https://www.google.com/maps/search/${Uri.encodeComponent(q)}/$center');
              return OutlinedButton.icon(
                onPressed: () => launchUrl(url, mode: LaunchMode.externalApplication),
                icon: const Icon(Icons.map),
                label: Text('$kwã‚’æ¢ã™'),
                style: OutlinedButton.styleFrom(
                  foregroundColor: color,
                  side: BorderSide(color: color.withValues(alpha: 0.5)),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(22)),
                ),
              );
            }).toList(),
          )
        ],
      ),
    );
  }

  // ğŸŒŸ AIãŠã™ã™ã‚ã‚«ãƒ¼ãƒ‰ï¼ˆâœ…è¿½åŠ ï¼‰
  Widget _aiRecommendationCard() {
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            "ğŸŒŸ ã‚ãªãŸã«ãŠã™ã™ã‚ã®æ¬¡ã®å±±",
            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18),
          ),
          const SizedBox(height: 8),
          const Text(
            "éå»ã®ç™»å±±å‚¾å‘ã‹ã‚‰AIãŒã‚ãªãŸã«åˆã†å±±ã‚’ææ¡ˆã—ã¾ã™ğŸŒ¿",
            style: TextStyle(fontSize: 14, color: Colors.black87, height: 1.5),
          ),
          const SizedBox(height: 10),
          Align(
            alignment: Alignment.centerLeft,
            child: OutlinedButton.icon(
              onPressed: () {
                // ã²ã¨ã¾ãšå‰ã®ç”»é¢ï¼ˆæ¤œç´¢çµæœï¼‰ã¸æˆ»ã‚‹ã“ã¨ã§ä»–å€™è£œã‚’è¦‹ã‚‰ã‚Œã‚‹å°ç·šã‚’ç”¨æ„
                Navigator.maybePop(context);
              },
              icon: const Icon(Icons.list_alt),
              label: const Text('ä»–ã®å€™è£œã‚’è¦‹ã‚‹'),
              style: OutlinedButton.styleFrom(
                foregroundColor: const Color(0xFF267365),
                side: const BorderSide(color: Color(0xFF267365)),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
              ),
            ),
          )
        ],
      ),
    );
  }

  // ğŸ’¬ AIãƒãƒ£ãƒƒãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³
  Widget _chatSection() {
    final mountainId = widget.mountain["name"];
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("ğŸ§­ AIãƒã‚¦ãƒ³ãƒ†ãƒ³ã‚³ãƒ³ã‚·ã‚§ãƒ«ã‚¸ãƒ¥",
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
          const SizedBox(height: 8),
          Builder(
            builder: (context) {
              if (_chatFirestoreOk) {
                return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
                  stream: ChatService.getMessages(mountainId),
                  builder: (context, snap) {
                    if (snap.hasError) {
                      // æ¨©é™ã‚¨ãƒ©ãƒ¼ãªã©ã€‚ä»¥é™ã¯ãƒ­ãƒ¼ã‚«ãƒ«AIãƒ¢ãƒ¼ãƒ‰ã«åˆ‡æ›¿ã€‚
                      if (_chatFirestoreOk) {
                        WidgetsBinding.instance.addPostFrameCallback((_) {
                          if (mounted) setState(() => _chatFirestoreOk = false);
                        });
                      }
                      return _chatFallbackNotice();
                    }
                    if (!snap.hasData) {
                      return const Padding(
                        padding: EdgeInsets.all(8.0),
                        child: LinearProgressIndicator(minHeight: 4),
                      );
                    }
                    final msgs = snap.data!.docs;
                    if (msgs.isEmpty) {
                      return const Padding(
                        padding: EdgeInsets.symmetric(vertical: 8),
                        child: Text(
                          'ã¾ã ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ°—è»½ã«è³ªå•ã—ã¦ã¿ã¦ãã ã•ã„ã€‚',
                          style: TextStyle(color: Colors.black54),
                        ),
                      );
                    }
                    return Column(
                      children: msgs.map((m) {
                        final d = m.data();
                        final isUser = d["role"] == "user";
                        return Container(
                          margin: EdgeInsets.only(
                              top: 6,
                              bottom: 6,
                              left: isUser ? 50 : 0,
                              right: isUser ? 0 : 50),
                          padding: const EdgeInsets.all(10),
                          decoration: BoxDecoration(
                            color: isUser
                                ? const Color(0xFFF2CB05)
                                : const Color(0xFFE7F5EE),
                            borderRadius: BorderRadius.circular(16),
                          ),
                          child: Text(d["text"],
                              style: const TextStyle(height: 1.4)),
                        );
                      }).toList(),
                    );
                  },
                );
              }
              // ãƒ­ãƒ¼ã‚«ãƒ«AIãƒ¢ãƒ¼ãƒ‰
              if (_localChat.isEmpty) {
                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _chatFallbackNotice(),
                    const SizedBox(height: 8),
                    const Text(
                      'ã¯ã˜ã‚ã¾ã—ã¦ï¼è¡ŒããŸã„æ™‚é–“ã‚„ä½“åŠ›ã€ç«‹ã¡å¯„ã‚ŠãŸã„æ¸©æ³‰ãªã©ã€è‡ªç”±ã«æ•™ãˆã¦ãã ã•ã„ã€‚',
                      style: TextStyle(color: Colors.black87),
                    ),
                  ],
                );
              }
              return Column(
                children: _localChat.map((d) {
                  final isUser = d['role'] == 'user';
                  return Container(
                    margin: EdgeInsets.only(
                        top: 6,
                        bottom: 6,
                        left: isUser ? 50 : 0,
                        right: isUser ? 0 : 50),
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: isUser
                          ? const Color(0xFFF2CB05)
                          : const Color(0xFFE7F5EE),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Text(d['text'] ?? '',
                        style: const TextStyle(height: 1.4)),
                  );
                }).toList(),
              );
            },
          ),
          const SizedBox(height: 10),
          Row(
            children: [
              Expanded(
                child: TextField(
                  controller: _chatCtrl,
                  maxLines: 1,
                  textInputAction: TextInputAction.send,
                  decoration: const InputDecoration(
                    hintText: "ç™»å±±è¨ˆç”»ã‚’ç›¸è«‡ã—ã¦ã¿ã‚ˆã†â€¦",
                    border: OutlineInputBorder(),
                  ),
                  onSubmitted: (_) => _handleSendMessage(),
                ),
              ),
              IconButton(
                onPressed: _handleSendMessage,
                icon: _isSendingLocalAi
                    ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2))
                    : const Icon(Icons.send, color: Color(0xFF00939C)),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _chatFallbackNotice() {
    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: const Color(0xFFFFF3E0),
        border: Border.all(color: const Color(0xFFFFCC80)),
        borderRadius: BorderRadius.circular(12),
      ),
      child: const Text(
        'ç¾åœ¨ã€ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã®ä¿å­˜ã«å¿…è¦ãªã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆFirestoreæœªè¨­å®š/æ¨©é™ä¸è¶³ï¼‰ã€‚\nã“ã®å ´ã§ã¯ãƒ­ãƒ¼ã‚«ãƒ«AIãƒ¢ãƒ¼ãƒ‰ã§å›ç­”ã—ã¾ã™ï¼ˆå±¥æ­´ã¯ç«¯æœ«ã«ä¿å­˜ã•ã‚Œã¾ã›ã‚“ï¼‰ã€‚',
        style: TextStyle(color: Colors.black87, height: 1.4),
      ),
    );
  }

  Future<void> _handleSendMessage() async {
    final mountainId = widget.mountain["name"];
    final msg = _chatCtrl.text.trim();
    if (msg.isEmpty) return;
    _chatCtrl.clear();
    if (_chatFirestoreOk) {
      try {
        await ChatService.sendAndReply(
          mountainId: mountainId,
          userText: msg,
          departureLabel: widget.departureLabel,
          searchContext: {
            'plannedDate': widget.plannedDate?.toIso8601String(),
            'mountain': widget.mountain,
          },
        );
      } catch (_) {
        if (mounted) setState(() => _chatFirestoreOk = false);
        await _sendLocalAiMessage(msg);
      }
    } else {
      await _sendLocalAiMessage(msg);
    }
  }

  Future<void> _sendLocalAiMessage(String userText) async {
    // ç”»é¢ã«å³æ™‚åæ˜ 
    setState(() {
      _localChat.add({'role': 'user', 'text': userText});
      _isSendingLocalAi = true;
    });

    final m = widget.mountain;
    final name = (m['name'] ?? '').toString();
    final pref = (m['pref'] ?? '').toString();
    final course = (m['course'] ?? m['popularRoute'] ?? '').toString();
    final system = 'ã‚ãªãŸã¯ç™»å±±ãƒ—ãƒ©ãƒ³ã®AIã‚³ãƒ³ã‚·ã‚§ãƒ«ã‚¸ãƒ¥ã§ã™ã€‚æ—¥æœ¬èªã§ç°¡æ½”ãƒ»å®‰å…¨ç¬¬ä¸€ã®ææ¡ˆã‚’ã—ã¾ã™ã€‚';
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢æ¡ä»¶ã‚’å«ã‚ã‚‹
    final searchConditions = <String>[];
    if (widget.selectedLevel != null && widget.selectedLevel!.isNotEmpty) {
      searchConditions.add('ãƒ»é›£æ˜“åº¦: ${widget.selectedLevel}');
    }
    if (widget.selectedAccessTime != null && widget.selectedAccessTime!.isNotEmpty) {
      searchConditions.add('ãƒ»ã‚¢ã‚¯ã‚»ã‚¹æ™‚é–“: ${widget.selectedAccessTime}');
    }
    if (widget.selectedCourseTime != null && widget.selectedCourseTime!.isNotEmpty) {
      searchConditions.add('ãƒ»ã‚³ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ : ${widget.selectedCourseTime}');
    }
    if (widget.selectedStyles != null && widget.selectedStyles!.isNotEmpty) {
      searchConditions.add('ãƒ»ç™»å±±ã‚¹ã‚¿ã‚¤ãƒ«: ${widget.selectedStyles!.join('ã€')}');
    }
    if (widget.selectedPurposes != null && widget.selectedPurposes!.isNotEmpty) {
      searchConditions.add('ãƒ»ç›®çš„: ${widget.selectedPurposes!.join('ã€')}');
    }
    if (widget.priorityPrefs != null && widget.priorityPrefs!.isNotEmpty) {
      final prefs = widget.priorityPrefs!.entries
          .where((e) => e.value == 'must')
          .map((e) => e.key)
          .join('ã€');
      if (prefs.isNotEmpty) searchConditions.add('ãƒ»å„ªå…ˆæ¡ä»¶: $prefs');
    }
    
    final user = [
      'æ¬¡ã®å±±ã«é–¢ã™ã‚‹ç›¸è«‡: $userText',
      if (name.isNotEmpty) 'ãƒ»å±±å: $name',
      if (pref.isNotEmpty) 'ãƒ»éƒ½é“åºœçœŒ: $pref',
      if (course.isNotEmpty) 'ãƒ»ä»£è¡¨ã‚³ãƒ¼ã‚¹: $course',
      if ((widget.departureLabel).isNotEmpty) 'ãƒ»å‡ºç™ºåœ°: ${widget.departureLabel}',
      if (widget.plannedDate != null)
        'ãƒ»ç™»å±±æ—¥: ${widget.plannedDate!.toIso8601String().split('T').first}',
      if (searchConditions.isNotEmpty) '\nã€æ¤œç´¢æ¡ä»¶ã€‘',
      ...searchConditions,
      '\nå‡ºåŠ›ã¯ç®‡æ¡æ›¸ãä¸­å¿ƒã€æ³¨æ„ç‚¹ã‚’æœ€å¾Œã«1ã€œ2è¡Œå«ã‚ã¦ãã ã•ã„ã€‚',
    ].join('\n');

    String reply;
    try {
      reply = await ApiService
          .askGemini(
            systemPrompt: system,
            userMessage: user,
            context: {
              'mountain': {
                'name': name,
                'pref': pref,
                'course': course,
              },
              'departure': widget.departureLabel,
              'plannedDate': widget.plannedDate?.toIso8601String(),
              'searchConditions': searchConditions,
            },
          )
          .timeout(const Duration(seconds: 25));
    } catch (_) {
      // ã§ãã‚‹ã ã‘ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç”Ÿã®ã‚¨ãƒ©ãƒ¼ã‚’è¦‹ã›ãªã„å‰å‘ããƒ¡ãƒƒã‚»ãƒ¼ã‚¸
      reply = 'ç¾åœ¨AIã¸ã®æ¥ç¶šãŒä¸å®‰å®šã§ã™ã€‚å°‘ã—æ™‚é–“ã‚’ãŠã„ã¦ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚\n\n'+
          'ãƒ»æ€¥ãã®å ´åˆã¯ã€Œæ‰€è¦æ™‚é–“ã‚’çŸ­ã‚ã«ã€ã€Œä½å±±ã§é™ã‹ãªã‚³ãƒ¼ã‚¹ã€ãªã©æ¡ä»¶ã‚’å…·ä½“çš„ã«æ›¸ãã¨ã€\n' +
          '  ã‚ˆã‚Šæ­£ç¢ºãªææ¡ˆãŒã—ã‚„ã™ããªã‚Šã¾ã™ã€‚';
    }

    if (!mounted) return;
    setState(() {
      _localChat.add({'role': 'assistant', 'text': reply});
      _isSendingLocalAi = false;
    });
  }

  // ğŸ’– ã‚·ã‚§ã‚¢
  Widget _shareButtons() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        ElevatedButton.icon(
          onPressed: () => launchUrl(
              Uri.parse("https://line.me/R/msg/text/?æ™´ã‚ŒãŸã‚‰ã„ã„ã­ï¼AIãƒ—ãƒ©ãƒ³ã‚’ã‚·ã‚§ã‚¢ğŸŒ¸"),
              mode: LaunchMode.externalApplication),
          icon: const Icon(Icons.share, color: Colors.white),
          label:
              const Text("LINEã§ã‚·ã‚§ã‚¢", style: TextStyle(color: Colors.white)),
          style: ElevatedButton.styleFrom(
              backgroundColor: Colors.green,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(30))),
        ),
        const SizedBox(width: 12),
        ElevatedButton.icon(
          onPressed: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (_) => const PlanHistoryPage(userId: "guest"))),
          icon: const Icon(Icons.history, color: Colors.white),
          label: const Text("å±¥æ­´ã‚’è¦‹ã‚‹",
              style: TextStyle(color: Colors.white)),
          style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF204E37),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(30))),
        ),
      ],
    );
  }

  // ğŸ’¾ ä¿å­˜
  Widget _saveAndHistoryButtons(BuildContext context) {
    final mountain = widget.mountain;
    return Center(
      child: ElevatedButton.icon(
        onPressed: () async {
          await FirestoreService.savePlan({
            "mountainName": mountain["name"],
            "departure": widget.departureLabel,
            "timestamp": DateTime.now().toIso8601String(),
          });
          if (!context.mounted) return;
          ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text("AIãƒ—ãƒ©ãƒ³ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼")));
        },
        icon: const Icon(Icons.bookmark, color: Colors.white),
        label: const Text("ã“ã®ãƒ—ãƒ©ãƒ³ã‚’ä¿å­˜",
            style: TextStyle(color: Colors.white)),
        style: ElevatedButton.styleFrom(
            backgroundColor: const Color(0xFFF20390),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(30))),
      ),
    );
  }

  // ğŸ’ ã‚«ãƒ¼ãƒ‰è£…é£¾
  Widget _cardContainer({required Widget child}) {
    return Container(
      padding: const EdgeInsets.all(16),
      margin: const EdgeInsets.only(bottom: 14),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(18),
        boxShadow: [
          BoxShadow(
              color: Colors.black.withValues(alpha: 0.08),
              blurRadius: 8,
              offset: const Offset(0, 4)),
        ],
      ),
      child: child,
    );
  }
}