import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import '../widgets/simple_sun_icon.dart';
import '../services/firestore_service.dart';
import '../services/chat_service.dart';
import '../services/open_meteo_service.dart';
import '../services/places_service.dart';
import '../services/mountain_info_ai_service.dart';
import '../services/api_service.dart';
import '../services/weather_score.dart';
import 'plan_history_page.dart'; // ✅ 履歴ページ

// ヘルパークラス：目的地情報
class _Dest {
  final String title;
  final double? lat;
  final double? lng;
  _Dest({required this.title, required this.lat, required this.lng});
}

class DetailPage extends StatefulWidget {
  final Map<String, dynamic> mountain;
  final String departureLabel;
  final DateTime? plannedDate;
  final double? departureLat;
  final double? departureLng;
  final String? selectedLevel;
  final String? selectedAccessTime;
  final String? selectedCourseTime;
  final List<String>? selectedStyles;
  final List<String>? selectedPurposes;
  final Map<String, String>? priorityPrefs;

  const DetailPage({
    super.key,
    required this.mountain,
    required this.departureLabel,
    this.plannedDate,
    this.departureLat,
    this.departureLng,
    this.selectedLevel,
    this.selectedAccessTime,
    this.selectedCourseTime,
    this.selectedStyles,
    this.selectedPurposes,
    this.priorityPrefs,
  });

  @override
  State<DetailPage> createState() => _DetailPageState();
}

class _DetailPageState extends State<DetailPage> {
  final TextEditingController _chatCtrl = TextEditingController();
  bool _isFavorite = false;
  int? _selectedTrailheadIndex;
  // State fields
  String _placesSortMode = 'rating'; // or 'distance'
  int _descReload = 0; // AI説明の再取得用
  bool _chatFirestoreOk = true; // Firestore利用可否
  final List<Map<String, String>> _localChat = []; // Firestore不可時のローカルログ
  bool _isSendingLocalAi = false; // 送信中スピナー表示
  List<Map<String, String>> _userSpots = []; // ユーザー追加の周辺スポット

  Future<void> _loadUserSpots() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final key = 'user_spots:${(widget.mountain['name'] ?? '').toString()}';
      final raw = prefs.getString(key);
      if (raw != null && raw.isNotEmpty) {
        final decoded = json.decode(raw);
        if (decoded is List) {
          final list = decoded
              .whereType<Map>()
              .map((m) => m.map((k, v) => MapEntry(k.toString(), (v ?? '').toString())))
              .toList();
          if (mounted) setState(() => _userSpots = list.cast<Map<String, String>>());
        }
      }
    } catch (_) {}
  }

  Future<void> _saveUserSpots() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final key = 'user_spots:${(widget.mountain['name'] ?? '').toString()}';
      await prefs.setString(key, json.encode(_userSpots));
    } catch (_) {}
  }

  Future<void> _showAddSpotDialog() async {
    final nameCtrl = TextEditingController();
    final urlCtrl = TextEditingController();
    final memoCtrl = TextEditingController();
    await showDialog(
      context: context,
      builder: (ctx) {
        return AlertDialog(
          title: const Text('周辺スポットを追加'),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                TextField(
                  controller: nameCtrl,
                  decoration: const InputDecoration(labelText: '名前（必須）'),
                  textInputAction: TextInputAction.next,
                ),
                const SizedBox(height: 8),
                TextField(
                  controller: urlCtrl,
                  decoration: const InputDecoration(labelText: 'URL（任意）'),
                  keyboardType: TextInputType.url,
                ),
                const SizedBox(height: 8),
                TextField(
                  controller: memoCtrl,
                  decoration: const InputDecoration(labelText: 'メモ（任意）'),
                  maxLines: 3,
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(ctx),
              child: const Text('キャンセル'),
            ),
            TextButton(
              onPressed: () async {
                final name = nameCtrl.text.trim();
                final url = urlCtrl.text.trim();
                final memo = memoCtrl.text.trim();
                if (name.isEmpty) return; // 必須
                setState(() {
                  _userSpots.add({'name': name, 'url': url, 'memo': memo});
                });
                await _saveUserSpots();
                if (mounted) Navigator.pop(ctx);
              },
              child: const Text('追加する'),
            ),
          ],
        );
      },
    );
  }

  @override
  void initState() {
    super.initState();
    _loadUserSpots();
  }

  @override
  Widget build(BuildContext context) {
    final mountain = widget.mountain;

    return Scaffold(
      backgroundColor: const Color(0xFFF8FBFB),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [
              Color(0xFF1E4F45), // deep green
              Color(0xFF2B6F63), // pine
              Color(0xFFF7D154), // warm yellow
            ],
            stops: [0.0, 0.55, 1.0],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
        ),
        child: SafeArea(
          child: SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(16, 10, 16, 100),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: 20),
                _appTitle(),
                const SizedBox(height: 10),
                _header(context, mountain),
                const SizedBox(height: 10),
                _mountainInfoCard(mountain),
                if (widget.plannedDate != null) ...[
                  const SizedBox(height: 10),
                  _scheduleBanner(widget.plannedDate!),
                ],
                const SizedBox(height: 16),
                _weatherIndexCard(mountain),
                const SizedBox(height: 12),
                _weatherCard(mountain),
                const SizedBox(height: 16),
                _mapCard(mountain), // ✅ 地図カード
                const SizedBox(height: 16),
                _trailheadInfoCard(mountain),
                const SizedBox(height: 16),
                _descriptionCard(mountain),
                const SizedBox(height: 16),
                _relaxLinksCard(mountain),
                const SizedBox(height: 16),
                _gourmetLinksCard(mountain),
                const SizedBox(height: 16),
                _nearbyPlacesCard(mountain),
                const SizedBox(height: 20),
                _aiRecommendationCard(), // ✅ AIおすすめカード
                const SizedBox(height: 20),
                _chatSection(),
                const SizedBox(height: 24),
                _shareButtons(),
                const SizedBox(height: 20),
                _saveAndHistoryButtons(context),
              ],
            ),
          ),
        ),
      ),
      bottomNavigationBar: _fixedBackButton(context),
    );
  }

  // 固定フッター：検索結果に戻る
  Widget _fixedBackButton(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          colors: [Color(0xFF2E7D32), Color(0xFF7CB342), Color(0xFF104E41)],
          begin: Alignment.centerLeft,
          end: Alignment.centerRight,
        ),
        boxShadow: [
          BoxShadow(
            color: const Color(0xFF104E41).withValues(alpha: 0.3),
            blurRadius: 12,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: SafeArea(
        child: InkWell(
          onTap: () => Navigator.pop(context),
          child: Container(
            padding: const EdgeInsets.symmetric(vertical: 16),
            child: const Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.arrow_back_ios, color: Colors.white, size: 18),
                SizedBox(width: 8),
                Text(
                  '検索結果に戻る',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 0.5,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  // 💚 ヘッダー
  Widget _header(BuildContext context, Map<String, dynamic> mountain) {
    return Row(
      children: [
        IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => Navigator.pop(context),
        ),
        Expanded(
          child: Center(
            child: Text(
              "${mountain["name"]}（${mountain["pref"]}）",
              style: const TextStyle(
                fontSize: 22,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
          ),
        ),
        IconButton(
          icon: Icon(
            _isFavorite ? Icons.favorite : Icons.favorite_border,
            color: Colors.pinkAccent,
          ),
          onPressed: () => setState(() => _isFavorite = !_isFavorite),
        ),
      ],
    );
  }

  // � アプリタイトル（検索と統一）
  Widget _appTitle() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      mainAxisSize: MainAxisSize.min,
      children: const [
        SimpleSunIcon(size: 20),
        SizedBox(width: 8),
        Text(
          '晴れ山 SEARCH',
          style: TextStyle(
            color: Colors.white,
            fontSize: 24,
            fontWeight: FontWeight.w800,
            letterSpacing: 1.2,
          ),
        ),
      ],
    );
  }

  // 🗓 日程（詳細ページ上部）
  Widget _scheduleBanner(DateTime day) {
    final d = DateTime(day.year, day.month, day.day)
        .toIso8601String()
        .split('T')
        .first
        .replaceAll('-', '/');
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: 0.92),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: const Color(0xFF00939C).withValues(alpha: 0.25)),
      ),
      child: Row(
        children: [
          const Icon(Icons.calendar_month_rounded, color: Color(0xFF00939C)),
          const SizedBox(width: 8),
          Text('登山日：$d', style: const TextStyle(fontWeight: FontWeight.w700)),
        ],
      ),
    );
  }

  // �🌤 天気カード（API連携：登山日の24時間・横スクロール）
  Widget _weatherCard(Map<String, dynamic> m) {
    final double? lat = (m['lat'] is num) ? (m['lat'] as num).toDouble() : null;
    final double? lng = (m['lng'] is num) ? (m['lng'] as num).toDouble() : null;
    final DateTime target = widget.plannedDate ?? DateTime.now();

    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            "⛰ 山の天気（1時間ごと）",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          if (lat == null || lng == null)
            const Text(
              '位置情報が不足しているため、この山の時間別天気を表示できません。',
              style: TextStyle(color: Colors.black54),
            )
          else
            FutureBuilder<List<Map<String, dynamic>>>(
              future: OpenMeteoService.fetchHourly(lat, lng, day: target),
              builder: (context, snap) {
                if (snap.connectionState == ConnectionState.waiting) {
                  return const Padding(
                    padding: EdgeInsets.symmetric(vertical: 8),
                    child: LinearProgressIndicator(minHeight: 4),
                  );
                }
                if (snap.hasError) {
                  return const Text('天気データの取得に失敗しました。時間をおいて再度お試しください。', 
                    style: TextStyle(color: Colors.black87));
                }
                final data = snap.data ?? const [];
                if (data.isEmpty) {
                  return const Text('この日の時間別天気データはありません。',
                    style: TextStyle(color: Colors.black87));
                }
                return SizedBox(
                  height: 150,
                  child: ListView.separated(
                    scrollDirection: Axis.horizontal,
                    itemCount: data.length,
                    separatorBuilder: (_, __) => const SizedBox(width: 10),
                    itemBuilder: (context, i) {
                      final e = data[i];
                      final timeStr = e['time']?.toString() ?? '';
                      final hh = (timeStr.length >= 13)
                          ? timeStr.substring(11, 13)
                          : '';
                      final hourLabel = hh.isNotEmpty ? '${int.tryParse(hh) ?? 0}時' : '';
                      final wcode = (e['weathercode'] as int?) ?? 0;
                      final emoji = OpenMeteoService.emojiFromWeatherCode(wcode);
                      final temp = (e['temp_c'] as num?)?.toDouble();
                      final wind = (e['wind_m_s'] as num?)?.toDouble();
                      final pop = ((e['pop'] as num?)?.toDouble() ?? 0.0) * 100;

                      return Container(
                        width: 100,
                        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
                        decoration: BoxDecoration(
                          gradient: const LinearGradient(
                            colors: [Color(0xFFFFF8E1), Color(0xFFFFFFFF)],
                            begin: Alignment.topCenter,
                            end: Alignment.bottomCenter,
                          ),
                          borderRadius: BorderRadius.circular(16),
                          border: Border.all(color: const Color(0xFF00939C).withValues(alpha: 0.3)),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withValues(alpha: 0.06),
                              blurRadius: 6,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(hourLabel, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 13)),
                            const SizedBox(height: 4),
                            _weatherVisual(wcode, emoji),
                            const SizedBox(height: 6),
                            if (temp != null)
                              Text('${temp.round()}°C', style: const TextStyle(fontSize: 15, fontWeight: FontWeight.w700, color: Color(0xFF1E4F45))),
                            const SizedBox(height: 6),
                            // 風速
                            if (wind != null) ...[
                              Row(
                                mainAxisAlignment: MainAxisAlignment.center,
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  const Icon(Icons.air, size: 14, color: Color(0xFF00939C)),
                                  const SizedBox(width: 2),
                                  Flexible(
                                    child: Text('風 ${wind.toStringAsFixed(1)}m/s', 
                                      style: const TextStyle(fontSize: 10, color: Color(0xFF424242)),
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 3),
                            ],
                            // 降水確率
                            Row(
                              mainAxisAlignment: MainAxisAlignment.center,
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                const Icon(Icons.water_drop, size: 14, color: Color(0xFF10ABB4)),
                                const SizedBox(width: 2),
                                Flexible(
                                  child: Text('雨 ${pop.round()}%', 
                                    style: const TextStyle(fontSize: 10, color: Color(0xFF424242)),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                );
              },
            ),
        ],
      ),
    );
  }

  Widget _weatherVisual(int weatherCode, String emoji) {
    // Clear sky (0) or mostly clear (1) → simple orange sun icon
    if (weatherCode == 0 || weatherCode == 1) {
      return const SimpleSunIcon(size: 26);
    }
    // Partly cloudy
    if (weatherCode == 2) {
      return const Icon(Icons.wb_cloudy, color: Color(0xFF90A4AE), size: 30);
    }
    // Cloud / rain fallback: keep emoji for variety
    return Text(emoji, style: const TextStyle(fontSize: 32));
  }

  // 🏔 山情報
  Widget _descriptionCard(Map<String, dynamic> m) {
    final hasDbDesc = ((m['description'] ?? '').toString().trim().isNotEmpty);
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("🏔 山の情報",
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 20)),
          const SizedBox(height: 10),
          if (hasDbDesc)
            Text(
              (m['description'] as String).trim(),
              style: const TextStyle(height: 1.6, color: Colors.black87),
            )
          else
            FutureBuilder<String?>(
              key: ValueKey('ai-desc-${m['name']}-${_descReload}'),
              future: MountainInfoAIService.getOrGenerateDescription(m),
              builder: (context, snap) {
                if (snap.connectionState == ConnectionState.waiting) {
                  return const Padding(
                    padding: EdgeInsets.symmetric(vertical: 4),
                    child: LinearProgressIndicator(minHeight: 4),
                  );
                }
                final text = (snap.data ?? '').toString().trim();
                if (text.isEmpty) {
                  return Row(
                    children: [
                      const Expanded(
                        child: Text(
                          '説明なし（AI生成を取得できませんでした）',
                          style: TextStyle(color: Colors.black54),
                        ),
                      ),
                      TextButton.icon(
                        onPressed: () => setState(() => _descReload++),
                        icon: const Icon(Icons.refresh, size: 18),
                        label: const Text('再試行'),
                      ),
                    ],
                  );
                }
                return Text(
                  text,
                  style: const TextStyle(height: 1.6, color: Colors.black87),
                );
              },
            ),
          const SizedBox(height: 12),
          SizedBox(
            width: double.infinity,
            child: OutlinedButton(
              onPressed: () => launchUrl(
                  Uri.parse("https://yamap.com/mountains/108"),
                  mode: LaunchMode.externalApplication),
              style: OutlinedButton.styleFrom(
                side: const BorderSide(color: Color(0xFFE57373), width: 1.5),
                foregroundColor: const Color(0xFFE57373),
                backgroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 14),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(40)),
              ),
              child: const Text(
                "🧭 YAMAPでコースをみる",
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
            ),
          ),
        ],
      ),
    );
  }

  // 📈 天気指数 & 今日のアドバイス（1日単位）
  Widget _weatherIndexCard(Map<String, dynamic> m) {
    final double? lat = (m['lat'] is num) ? (m['lat'] as num).toDouble() : null;
    final double? lng = (m['lng'] is num) ? (m['lng'] as num).toDouble() : null;
    final DateTime target = widget.plannedDate ?? DateTime.now();

    if (lat == null || lng == null) {
      return _cardContainer(
        child: const Text('位置情報が不足しているため、この日の天気指数を表示できません。', style: TextStyle(color: Colors.black54)),
      );
    }

    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('📈 天気指数と今日のアドバイス', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
          const SizedBox(height: 6),
          FutureBuilder<List<Map<String, dynamic>>>(
            future: OpenMeteoService.fetchDaily(lat, lng, days: 14),
            builder: (context, snap) {
              if (snap.connectionState == ConnectionState.waiting) {
                return const LinearProgressIndicator(minHeight: 4);
              }
              final days = snap.data ?? const [];
              if (days.isEmpty) {
                return const Text('天気指数を計算できませんでした。時間をおいて再度お試しください。',
                  style: TextStyle(color: Colors.black87));
              }
              final picked = OpenMeteoService.chooseBestOrDate(days, target: target) ?? days.first;
              final f = {
                'pop': (picked['pop'] as num?)?.toDouble() ?? double.nan,
                'wind_m_s': (picked['wind_m_s'] as num?)?.toDouble() ?? double.nan,
                'cloud_pct': (picked['cloud_pct'] as num?)?.toDouble() ?? double.nan,
                'temp_c': (picked['temp_c'] as num?)?.toDouble() ?? double.nan,
                'precip_mm': 0.0,
              };
              final res = WeatherScore.scoreDay(f);
              final score = (res['score'] as int?) ?? 0;
              final reason = (res['reason'] as String?) ?? '';
              final breakdown = (res['breakdown'] as Map?) ?? const {};
              final advice = _buildDailyAdvice(score, breakdown, picked);

              Color badgeColor;
              if (score >= 75) {
                badgeColor = const Color(0xFF2E7D32);
              } else if (score >= 50) {
                badgeColor = const Color(0xFFF9A825);
              } else {
                badgeColor = const Color(0xFFD32F2F);
              }

              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                        decoration: BoxDecoration(color: badgeColor, borderRadius: BorderRadius.circular(20)),
                        child: Text('$score', style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                      ),
                      const SizedBox(width: 8),
                      const Text('天気指数（0-100）', style: TextStyle(fontWeight: FontWeight.w600)),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(reason, style: const TextStyle(color: Colors.black87)),
                  const SizedBox(height: 6),
                  Text(advice, style: const TextStyle(color: Colors.black87, height: 1.5)),
                ],
              );
            },
          ),
        ],
      ),
    );
  }

  String _buildDailyAdvice(int score, Map breakdown, Map picked) {
    if (score >= 85) {
      return '今日は絶好の山日和！展望や稜線歩きをたっぷり楽しめそうです。日焼け・水分補給の準備をお忘れなく。';
    } else if (score >= 70) {
      return '良い条件です。午前を中心に計画すると、より気持ちよく歩けます。午後は余裕をもって安全に。';
    } else if (score >= 55) {
      return '少し揺らぎはありますが、樹林帯中心や低山コースなら快適に楽しめます。早めの行動でゆとりを。';
    } else {
      return '今日は静かな山時間を。近場のハイキングや別日の快晴狙いも素敵です。安全第一で無理なく。';
    }
  }

  // 🚏 登山口情報カード
  Widget _trailheadInfoCard(Map<String, dynamic> m) {
    String orDash(String s) => (s.isNotEmpty) ? s : '—';
    final List ths = (m['trailheads'] is List) ? (m['trailheads'] as List) : const [];

    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            '🚏 登山口情報',
            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18),
          ),
          const SizedBox(height: 10),
          if (ths.isEmpty) ...[
            _trailRow(Icons.flag, '登山口名', orDash('${m['name'] ?? ''} 登山口')),
            const SizedBox(height: 6),
            _trailRow(Icons.place, '住所', orDash((m['address'] ?? '').toString())),
            const SizedBox(height: 6),
            _trailRow(Icons.local_parking, '駐車場', orDash((m['parking'] ?? '').toString())),
            const SizedBox(height: 6),
            _trailRow(Icons.wc, 'トイレ', orDash((m['toilet'] ?? '').toString())),
          ] else ...[
            ...ths.asMap().entries.map((entry) {
              final i = entry.key;
              final th = Map<String, dynamic>.from(entry.value as Map);
              final tname = (th['name'] ?? '${m['name'] ?? ''} 登山口${i + 1}').toString();
              final taddr = (th['address'] ?? '').toString();
              final tpark = (th['parking'] ?? '').toString();
              final ttlt = (th['toiletSeason'] ?? th['toilet'] ?? '').toString();
              return Padding(
                padding: EdgeInsets.only(bottom: i == ths.length - 1 ? 0 : 10),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _trailRow(Icons.flag, '登山口名', orDash(tname)),
                    const SizedBox(height: 6),
                    _trailRow(Icons.place, '住所', orDash(taddr)),
                    const SizedBox(height: 6),
                    _trailRow(Icons.local_parking, '駐車場', orDash(tpark)),
                    const SizedBox(height: 6),
                    _trailRow(Icons.wc, 'トイレ', orDash(ttlt)),
                  ],
                ),
              );
            })
          ]
        ],
      ),
    );
  }

  Widget _trailRow(IconData icon, String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, color: const Color(0xFF267365)),
        const SizedBox(width: 10),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label, style: const TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 2),
              Text(value),
            ],
          ),
        )
      ],
    );
  }

  // 🧭 周辺スポット（Google Places が設定されているときのみ表示）
  Widget _nearbyPlacesCard(Map<String, dynamic> m) {
    if (!PlacesService.isConfigured) {
      return const SizedBox.shrink();
    }
    final List ths = (m['trailheads'] is List) ? (m['trailheads'] as List) : const [];
    double? lat = (m['lat'] is num) ? (m['lat'] as num).toDouble() : null;
    double? lng = (m['lng'] is num) ? (m['lng'] as num).toDouble() : null;
    if (ths.isNotEmpty) {
      final int idx = _selectedTrailheadIndex ?? 0;
      final Map th = Map.from(ths[idx]);
      final tlat = th['lat'];
      final tlng = th['lng'];
      if (tlat is num && tlng is num) {
        lat = tlat.toDouble();
        lng = tlng.toDouble();
      }
    }
    if (lat == null || lng == null) {
      return const SizedBox.shrink();
    }
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('🔎 周辺スポット（Google）', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
          const SizedBox(height: 8),
          Row(
            children: [
              ChoiceChip(
                label: const Text('評価順'),
                selected: _placesSortMode == 'rating',
                onSelected: (v) => setState(() => _placesSortMode = 'rating'),
              ),
              const SizedBox(width: 8),
              ChoiceChip(
                label: const Text('距離順'),
                selected: _placesSortMode == 'distance',
                onSelected: (v) => setState(() => _placesSortMode = 'distance'),
              ),
            ],
          ),
          const SizedBox(height: 8),
          FutureBuilder<List<Map<String, dynamic>>>(
            future: PlacesService.nearbyOnsenAndFoodWeighted(lat, lng, radiusMeters: 15000, sort: _placesSortMode),
            builder: (context, snap) {
              if (snap.connectionState == ConnectionState.waiting) {
                return const LinearProgressIndicator(minHeight: 4);
              }
              if (!snap.hasData || snap.data == null) {
                return _emptySpotsBlock(showAdd: true);
              }
              final show = snap.data!;
              if (show.isEmpty) {
                return _emptySpotsBlock(showAdd: true);
              }
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  ...show.map((e) {
                    final rating = (e['rating'] as num?)?.toDouble();
                    final distKm = (e['distanceKm'] as num?)?.toDouble();
                    final subtitle = [
                      if (rating != null && rating > 0) '⭐ ${rating.toStringAsFixed(1)}',
                      if (distKm != null) '${distKm.toStringAsFixed(1)}km',
                      if ((e['desc'] ?? '').toString().isNotEmpty) (e['desc'] as String),
                    ].join(' ・ ');
                    return GestureDetector(
                      onTap: () => launchUrl(Uri.parse(e['url']), mode: LaunchMode.externalApplication),
                      child: Container(
                        margin: const EdgeInsets.only(bottom: 8),
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.white,
                          border: Border.all(color: const Color(0xFF267365).withValues(alpha: 0.3)),
                          borderRadius: BorderRadius.circular(14),
                        ),
                        child: ListTile(
                          title: Text(e['name'], style: const TextStyle(fontWeight: FontWeight.bold)),
                          subtitle: Text(subtitle),
                          trailing: const Icon(Icons.map, color: Color(0xFF267365)),
                        ),
                      ),
                    );
                  }).toList(),
                  if (_userSpots.isNotEmpty) ...[
                    const SizedBox(height: 10),
                    const Text('📝 ユーザー追加スポット', style: TextStyle(fontWeight: FontWeight.bold)),
                    const SizedBox(height: 6),
                    ..._userSpots.map((e) {
                      final subtitle = [
                        if ((e['memo'] ?? '').toString().isNotEmpty) (e['memo'] ?? ''),
                        if ((e['url'] ?? '').toString().isNotEmpty) 'リンクあり',
                      ].where((s) => s.isNotEmpty).join(' ・ ');
                      return GestureDetector(
                        onTap: () {
                          final u = (e['url'] ?? '').trim();
                          if (u.isNotEmpty) launchUrl(Uri.parse(u), mode: LaunchMode.externalApplication);
                        },
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF9FBFA),
                            border: Border.all(color: const Color(0xFF267365).withValues(alpha: 0.2)),
                            borderRadius: BorderRadius.circular(14),
                          ),
                          child: ListTile(
                            title: Text(e['name'] ?? '', style: const TextStyle(fontWeight: FontWeight.bold)),
                            subtitle: Text(subtitle.isEmpty ? '—' : subtitle),
                            trailing: const Icon(Icons.open_in_new, color: Color(0xFF267365)),
                          ),
                        ),
                      );
                    }).toList(),
                  ],
                ],
              );
            },
          ),
          if (_userSpots.isEmpty) ...[
            const SizedBox(height: 8),
            _emptySpotsHintNote(),
          ]
        ],
      ),
    );
  }

  Widget _emptySpotsBlock({bool showAdd = false}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: const Color(0xFFF0F7F7),
            border: Border.all(color: const Color(0xFF267365).withValues(alpha: 0.25)),
            borderRadius: BorderRadius.circular(12),
          ),
          child: const Text(
            '周辺スポットの情報がありません。見つけた情報を追加して、次に訪れる方に役立てましょう。',
            style: TextStyle(color: Colors.black87),
          ),
        ),
        const SizedBox(height: 8),
        if (showAdd)
          Align(
            alignment: Alignment.centerLeft,
            child: ElevatedButton.icon(
              onPressed: _showAddSpotDialog,
              icon: const Icon(Icons.add, color: Colors.white),
              label: const Text('スポットを追加', style: TextStyle(color: Colors.white)),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF267365),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
              ),
            ),
          ),
        if (_userSpots.isNotEmpty) ...[
          const SizedBox(height: 8),
          const Text('📝 ユーザー追加スポット', style: TextStyle(fontWeight: FontWeight.bold)),
          const SizedBox(height: 6),
          ..._userSpots.map((e) {
            final subtitle = [
              if ((e['memo'] ?? '').toString().isNotEmpty) (e['memo'] ?? ''),
              if ((e['url'] ?? '').toString().isNotEmpty) 'リンクあり',
            ].where((s) => s.isNotEmpty).join(' ・ ');
            return GestureDetector(
              onTap: () {
                final u = (e['url'] ?? '').trim();
                if (u.isNotEmpty) launchUrl(Uri.parse(u), mode: LaunchMode.externalApplication);
              },
              child: Container(
                margin: const EdgeInsets.only(bottom: 8),
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: const Color(0xFFF9FBFA),
                  border: Border.all(color: const Color(0xFF267365).withValues(alpha: 0.2)),
                  borderRadius: BorderRadius.circular(14),
                ),
                child: ListTile(
                  title: Text(e['name'] ?? '', style: const TextStyle(fontWeight: FontWeight.bold)),
                  subtitle: Text(subtitle.isEmpty ? '—' : subtitle),
                  trailing: const Icon(Icons.open_in_new, color: Color(0xFF267365)),
                ),
              ),
            );
          }).toList(),
        ],
      ],
    );
  }

  Widget _emptySpotsHintNote() {
    return const Text(
      '手元の情報（温泉・食事・観光スポットなど）があれば「スポットを追加」から追記できます。',
      style: TextStyle(color: Colors.black54, fontSize: 13.5),
    );
  }

  // 🗺 地図カード（✅追加）
  Widget _mapCard(Map<String, dynamic> mountain) {
    final double? lat = (mountain['lat'] is num) ? (mountain['lat'] as num).toDouble() : null;
    final double? lng = (mountain['lng'] is num) ? (mountain['lng'] as num).toDouble() : null;
    // trailheads
    final List ths = (mountain['trailheads'] is List) ? (mountain['trailheads'] as List) : const [];
    double? dLat = lat, dLng = lng;
    if (ths.isNotEmpty) {
      final int idx = _selectedTrailheadIndex ?? 0;
      final Map th = Map.from(ths[idx]);
      final tlat = th['lat'];
      final tlng = th['lng'];
      if (tlat is num && tlng is num) {
        dLat = tlat.toDouble();
        dLng = tlng.toDouble();
      }
    }
    final LatLng pos = (dLat != null && dLng != null) ? LatLng(dLat, dLng) : const LatLng(35.625, 139.243);
    final String mname = (mountain['name'] ?? '山').toString();
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("🗺 登山口アクセスマップ",
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
          if (ths.length > 1) ...[
            const SizedBox(height: 8),
            DropdownButtonFormField<int>(
              value: _selectedTrailheadIndex,
              items: ths.asMap().entries.map((e) {
                final i = e.key;
                final Map th = Map.from(e.value);
                final title = (th['name'] ?? '登山口${i + 1}').toString();
                return DropdownMenuItem<int>(value: i, child: Text(title));
              }).toList(),
              onChanged: (v) => setState(() => _selectedTrailheadIndex = v),
              decoration: const InputDecoration(
                labelText: '目的地の登山口を選択',
                border: OutlineInputBorder(),
                isDense: true,
              ),
            ),
          ],
          const SizedBox(height: 8),
          SizedBox(
            height: 220,
            child: GoogleMap(
              key: ValueKey('map-${_selectedTrailheadIndex ?? -1}'),
              onMapCreated: (controller) {},
              initialCameraPosition: CameraPosition(target: pos, zoom: 11),
              markers: {
                Marker(markerId: const MarkerId("mountain"), position: pos, infoWindow: InfoWindow(title: mname)),
              },
            ),
          ),
          const SizedBox(height: 12),
          ElevatedButton.icon(
            onPressed: () async {
              final oLat = widget.departureLat;
              final oLng = widget.departureLng;
              final String origin = (oLat != null && oLng != null && (oLat != 0 || oLng != 0))
                  ? '${oLat.toStringAsFixed(6)},${oLng.toStringAsFixed(6)}'
                  : (widget.departureLabel.isNotEmpty ? widget.departureLabel : '出発地');
              final hasPos = (pos.latitude != 0 && pos.longitude != 0);
              final destination = hasPos ? '${pos.latitude},${pos.longitude}' : '${widget.mountain["name"]} 登山口';
              final uri = Uri.https('www.google.com', '/maps/dir/', {
                'api': '1',
                'origin': origin,
                'destination': destination,
                'travelmode': 'driving',
              });
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri, mode: LaunchMode.externalApplication);
              }
            },
            icon: const Icon(Icons.directions_car, color: Colors.white),
            label: const Text("Googleマップで車ルート"),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF00939C),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(30)),
            ),
          ),
          const SizedBox(height: 8),
          ElevatedButton.icon(
            onPressed: () async {
              final oLat = widget.departureLat;
              final oLng = widget.departureLng;
              final String origin = (oLat != null && oLng != null && (oLat != 0 || oLng != 0))
                  ? '${oLat.toStringAsFixed(6)},${oLng.toStringAsFixed(6)}'
                  : (widget.departureLabel.isNotEmpty ? widget.departureLabel : '出発地');
              final hasPos = (pos.latitude != 0 && pos.longitude != 0);
              final destination = hasPos ? '${pos.latitude},${pos.longitude}' : '${widget.mountain["name"]} 登山口';
              final uri = Uri.https('www.google.com', '/maps/dir/', {
                'api': '1',
                'origin': origin,
                'destination': destination,
                'travelmode': 'transit',
              });
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri, mode: LaunchMode.externalApplication);
              }
            },
            icon: const Icon(Icons.train, color: Colors.white),
            label: const Text("Googleマップで公共交通ルート"),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF10ABB4),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(30)),
            ),
          ),
        ],
      ),
    );
  }

  // 🍴 周辺グルメ（郷土料理・そば）
  Widget _gourmetLinksCard(Map<String, dynamic> m) {
    final _Dest d = _resolveDestination(m);
    final base = d.title;
    final lat = d.lat;
    final lng = d.lng;
    final kws = ['郷土料理', 'そば'];
    return _linksCard(title: '周辺グルメ 🍴', color: const Color(0xFFE91E63), base: base, lat: lat, lng: lng, keywords: kws);
  }

  // ♨️ 周辺くつろぎ（温泉・サウナ・民宿・旅館・ホテル）
  Widget _relaxLinksCard(Map<String, dynamic> m) {
    final _Dest d = _resolveDestination(m);
    final base = d.title;
    final lat = d.lat;
    final lng = d.lng;
    final kws = ['温泉', 'サウナ', '民宿', '旅館', 'ホテル'];
    return _linksCard(title: '周辺くつろぎ ♨️', color: const Color(0xFFFF8F00), base: base, lat: lat, lng: lng, keywords: kws);
  }

  _Dest _resolveDestination(Map<String, dynamic> m) {
    final List ths = (m['trailheads'] is List) ? (m['trailheads'] as List) : const [];
    String title = (m['name'] ?? '').toString();
    double? lat = (m['lat'] is num) ? (m['lat'] as num).toDouble() : null;
    double? lng = (m['lng'] is num) ? (m['lng'] as num).toDouble() : null;
    if (ths.isNotEmpty) {
      final int idx = _selectedTrailheadIndex ?? 0;
      final Map th = Map.from(ths[idx]);
      final tlat = th['lat'];
      final tlng = th['lng'];
      if (tlat is num && tlng is num) {
        lat = tlat.toDouble();
        lng = tlng.toDouble();
      }
      title = (th['name'] ?? title).toString();
    }
    return _Dest(title: title, lat: lat, lng: lng);
  }

  Widget _linksCard({
    required String title,
    required Color color,
    required String base,
    required double? lat,
    required double? lng,
    required List<String> keywords,
  }) {
    final center = (lat != null && lng != null) ? '@${lat.toStringAsFixed(5)},${lng.toStringAsFixed(5)},14z' : '';
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(title, style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: color)),
          const SizedBox(height: 10),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: keywords.map((kw) {
              final q = '$base $kw';
              final url = Uri.parse('https://www.google.com/maps/search/${Uri.encodeComponent(q)}/$center');
              return OutlinedButton.icon(
                onPressed: () => launchUrl(url, mode: LaunchMode.externalApplication),
                icon: const Icon(Icons.map),
                label: Text('$kwを探す'),
                style: OutlinedButton.styleFrom(
                  foregroundColor: color,
                  side: BorderSide(color: color.withValues(alpha: 0.5)),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(22)),
                ),
              );
            }).toList(),
          )
        ],
      ),
    );
  }

  // 🌟 AIおすすめカード（✅追加）
  Widget _aiRecommendationCard() {
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            "🌟 あなたにおすすめの次の山",
            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18),
          ),
          const SizedBox(height: 8),
          const Text(
            "過去の登山傾向からAIがあなたに合う山を提案します🌿",
            style: TextStyle(fontSize: 14, color: Colors.black87, height: 1.5),
          ),
          const SizedBox(height: 10),
          Align(
            alignment: Alignment.centerLeft,
            child: OutlinedButton.icon(
              onPressed: () {
                // ひとまず前の画面（検索結果）へ戻ることで他候補を見られる導線を用意
                Navigator.maybePop(context);
              },
              icon: const Icon(Icons.list_alt),
              label: const Text('他の候補を見る'),
              style: OutlinedButton.styleFrom(
                foregroundColor: const Color(0xFF267365),
                side: const BorderSide(color: Color(0xFF267365)),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
              ),
            ),
          )
        ],
      ),
    );
  }

  // 💬 AIチャットセクション
  Widget _chatSection() {
    final mountainId = widget.mountain["name"];
    return _cardContainer(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("🧭 AIマウンテンコンシェルジュ",
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
          const SizedBox(height: 8),
          Builder(
            builder: (context) {
              if (_chatFirestoreOk) {
                return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
                  stream: ChatService.getMessages(mountainId),
                  builder: (context, snap) {
                    if (snap.hasError) {
                      // 権限エラーなど。以降はローカルAIモードに切替。
                      if (_chatFirestoreOk) {
                        WidgetsBinding.instance.addPostFrameCallback((_) {
                          if (mounted) setState(() => _chatFirestoreOk = false);
                        });
                      }
                      return _chatFallbackNotice();
                    }
                    if (!snap.hasData) {
                      return const Padding(
                        padding: EdgeInsets.all(8.0),
                        child: LinearProgressIndicator(minHeight: 4),
                      );
                    }
                    final msgs = snap.data!.docs;
                    if (msgs.isEmpty) {
                      return const Padding(
                        padding: EdgeInsets.symmetric(vertical: 8),
                        child: Text(
                          'まだメッセージはありません。気軽に質問してみてください。',
                          style: TextStyle(color: Colors.black54),
                        ),
                      );
                    }
                    return Column(
                      children: msgs.map((m) {
                        final d = m.data();
                        final isUser = d["role"] == "user";
                        return Container(
                          margin: EdgeInsets.only(
                              top: 6,
                              bottom: 6,
                              left: isUser ? 50 : 0,
                              right: isUser ? 0 : 50),
                          padding: const EdgeInsets.all(10),
                          decoration: BoxDecoration(
                            color: isUser
                                ? const Color(0xFFF2CB05)
                                : const Color(0xFFE7F5EE),
                            borderRadius: BorderRadius.circular(16),
                          ),
                          child: Text(d["text"],
                              style: const TextStyle(height: 1.4)),
                        );
                      }).toList(),
                    );
                  },
                );
              }
              // ローカルAIモード
              if (_localChat.isEmpty) {
                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _chatFallbackNotice(),
                    const SizedBox(height: 8),
                    const Text(
                      'はじめまして！行きたい時間や体力、立ち寄りたい温泉など、自由に教えてください。',
                      style: TextStyle(color: Colors.black87),
                    ),
                  ],
                );
              }
              return Column(
                children: _localChat.map((d) {
                  final isUser = d['role'] == 'user';
                  return Container(
                    margin: EdgeInsets.only(
                        top: 6,
                        bottom: 6,
                        left: isUser ? 50 : 0,
                        right: isUser ? 0 : 50),
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: isUser
                          ? const Color(0xFFF2CB05)
                          : const Color(0xFFE7F5EE),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Text(d['text'] ?? '',
                        style: const TextStyle(height: 1.4)),
                  );
                }).toList(),
              );
            },
          ),
          const SizedBox(height: 10),
          Row(
            children: [
              Expanded(
                child: TextField(
                  controller: _chatCtrl,
                  maxLines: 1,
                  textInputAction: TextInputAction.send,
                  decoration: const InputDecoration(
                    hintText: "登山計画を相談してみよう…",
                    border: OutlineInputBorder(),
                  ),
                  onSubmitted: (_) => _handleSendMessage(),
                ),
              ),
              IconButton(
                onPressed: _handleSendMessage,
                icon: _isSendingLocalAi
                    ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2))
                    : const Icon(Icons.send, color: Color(0xFF00939C)),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _chatFallbackNotice() {
    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: const Color(0xFFFFF3E0),
        border: Border.all(color: const Color(0xFFFFCC80)),
        borderRadius: BorderRadius.circular(12),
      ),
      child: const Text(
        '現在、チャット履歴の保存に必要なアクセス権限がありません（Firestore未設定/権限不足）。\nこの場ではローカルAIモードで回答します（履歴は端末に保存されません）。',
        style: TextStyle(color: Colors.black87, height: 1.4),
      ),
    );
  }

  Future<void> _handleSendMessage() async {
    final mountainId = widget.mountain["name"];
    final msg = _chatCtrl.text.trim();
    if (msg.isEmpty) return;
    _chatCtrl.clear();
    if (_chatFirestoreOk) {
      try {
        await ChatService.sendAndReply(
          mountainId: mountainId,
          userText: msg,
          departureLabel: widget.departureLabel,
          searchContext: {
            'plannedDate': widget.plannedDate?.toIso8601String(),
            'mountain': widget.mountain,
          },
        );
      } catch (_) {
        if (mounted) setState(() => _chatFirestoreOk = false);
        await _sendLocalAiMessage(msg);
      }
    } else {
      await _sendLocalAiMessage(msg);
    }
  }

  Future<void> _sendLocalAiMessage(String userText) async {
    // 画面に即時反映
    setState(() {
      _localChat.add({'role': 'user', 'text': userText});
      _isSendingLocalAi = true;
    });

    final m = widget.mountain;
    final name = (m['name'] ?? '').toString();
    final pref = (m['pref'] ?? '').toString();
    final course = (m['course'] ?? m['popularRoute'] ?? '').toString();
    final system = 'あなたは登山プランのAIコンシェルジュです。日本語で簡潔・安全第一の提案をします。';
    
    // ユーザー検索条件を含める
    final searchConditions = <String>[];
    if (widget.selectedLevel != null && widget.selectedLevel!.isNotEmpty) {
      searchConditions.add('・難易度: ${widget.selectedLevel}');
    }
    if (widget.selectedAccessTime != null && widget.selectedAccessTime!.isNotEmpty) {
      searchConditions.add('・アクセス時間: ${widget.selectedAccessTime}');
    }
    if (widget.selectedCourseTime != null && widget.selectedCourseTime!.isNotEmpty) {
      searchConditions.add('・コースタイム: ${widget.selectedCourseTime}');
    }
    if (widget.selectedStyles != null && widget.selectedStyles!.isNotEmpty) {
      searchConditions.add('・登山スタイル: ${widget.selectedStyles!.join('、')}');
    }
    if (widget.selectedPurposes != null && widget.selectedPurposes!.isNotEmpty) {
      searchConditions.add('・目的: ${widget.selectedPurposes!.join('、')}');
    }
    if (widget.priorityPrefs != null && widget.priorityPrefs!.isNotEmpty) {
      final prefs = widget.priorityPrefs!.entries
          .where((e) => e.value == 'must')
          .map((e) => e.key)
          .join('、');
      if (prefs.isNotEmpty) searchConditions.add('・優先条件: $prefs');
    }
    
    final user = [
      '次の山に関する相談: $userText',
      if (name.isNotEmpty) '・山名: $name',
      if (pref.isNotEmpty) '・都道府県: $pref',
      if (course.isNotEmpty) '・代表コース: $course',
      if ((widget.departureLabel).isNotEmpty) '・出発地: ${widget.departureLabel}',
      if (widget.plannedDate != null)
        '・登山日: ${widget.plannedDate!.toIso8601String().split('T').first}',
      if (searchConditions.isNotEmpty) '\n【検索条件】',
      ...searchConditions,
      '\n出力は箇条書き中心、注意点を最後に1〜2行含めてください。',
    ].join('\n');

    String reply;
    try {
      reply = await ApiService
          .askGemini(
            systemPrompt: system,
            userMessage: user,
            context: {
              'mountain': {
                'name': name,
                'pref': pref,
                'course': course,
              },
              'departure': widget.departureLabel,
              'plannedDate': widget.plannedDate?.toIso8601String(),
              'searchConditions': searchConditions,
            },
          )
          .timeout(const Duration(seconds: 25));
    } catch (_) {
      // できるだけユーザーに生のエラーを見せない前向きメッセージ
      reply = '現在AIへの接続が不安定です。少し時間をおいてもう一度お試しください。\n\n'+
          '・急ぎの場合は「所要時間を短めに」「低山で静かなコース」など条件を具体的に書くと、\n' +
          '  より正確な提案がしやすくなります。';
    }

    if (!mounted) return;
    setState(() {
      _localChat.add({'role': 'assistant', 'text': reply});
      _isSendingLocalAi = false;
    });
  }

  // 💖 シェア
  Widget _shareButtons() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        ElevatedButton.icon(
          onPressed: () => launchUrl(
              Uri.parse("https://line.me/R/msg/text/?晴れたらいいね！AIプランをシェア🌸"),
              mode: LaunchMode.externalApplication),
          icon: const Icon(Icons.share, color: Colors.white),
          label:
              const Text("LINEでシェア", style: TextStyle(color: Colors.white)),
          style: ElevatedButton.styleFrom(
              backgroundColor: Colors.green,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(30))),
        ),
        const SizedBox(width: 12),
        ElevatedButton.icon(
          onPressed: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (_) => const PlanHistoryPage(userId: "guest"))),
          icon: const Icon(Icons.history, color: Colors.white),
          label: const Text("履歴を見る",
              style: TextStyle(color: Colors.white)),
          style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF204E37),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(30))),
        ),
      ],
    );
  }

  // 💾 保存
  Widget _saveAndHistoryButtons(BuildContext context) {
    final mountain = widget.mountain;
    return Center(
      child: ElevatedButton.icon(
        onPressed: () async {
          await FirestoreService.savePlan({
            "mountainName": mountain["name"],
            "departure": widget.departureLabel,
            "timestamp": DateTime.now().toIso8601String(),
          });
          if (!context.mounted) return;
          ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text("AIプランを保存しました！")));
        },
        icon: const Icon(Icons.bookmark, color: Colors.white),
        label: const Text("このプランを保存",
            style: TextStyle(color: Colors.white)),
        style: ElevatedButton.styleFrom(
            backgroundColor: const Color(0xFFF20390),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(30))),
      ),
    );
  }

  // 💎 カード装飾
  Widget _cardContainer({required Widget child}) {
    return Container(
      padding: const EdgeInsets.all(16),
      margin: const EdgeInsets.only(bottom: 14),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(18),
        boxShadow: [
          BoxShadow(
              color: Colors.black.withValues(alpha: 0.08),
              blurRadius: 8,
              offset: const Offset(0, 4)),
        ],
      ),
      child: child,
    );
  }
}